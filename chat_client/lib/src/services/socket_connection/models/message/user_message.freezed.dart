// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'user_message.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

UserMessage _$UserMessageFromJson(Map<String, dynamic> json) {
  return _UserMessage.fromJson(json);
}

/// @nodoc
mixin _$UserMessage {
  int get key => throw _privateConstructorUsedError;
  int get connection => throw _privateConstructorUsedError;
  String get sender => throw _privateConstructorUsedError;
  String get receiver => throw _privateConstructorUsedError;
  String? get text => throw _privateConstructorUsedError;
  String? get parent => throw _privateConstructorUsedError;
  String? get voiceNote => throw _privateConstructorUsedError;
  int? get createdAt => throw _privateConstructorUsedError;
  int? get updatedAt => throw _privateConstructorUsedError;
  int? get deliverTime => throw _privateConstructorUsedError;
  int? get seenTime => throw _privateConstructorUsedError;

  /// Serializes this UserMessage to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of UserMessage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $UserMessageCopyWith<UserMessage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserMessageCopyWith<$Res> {
  factory $UserMessageCopyWith(
          UserMessage value, $Res Function(UserMessage) then) =
      _$UserMessageCopyWithImpl<$Res, UserMessage>;
  @useResult
  $Res call(
      {int key,
      int connection,
      String sender,
      String receiver,
      String? text,
      String? parent,
      String? voiceNote,
      int? createdAt,
      int? updatedAt,
      int? deliverTime,
      int? seenTime});
}

/// @nodoc
class _$UserMessageCopyWithImpl<$Res, $Val extends UserMessage>
    implements $UserMessageCopyWith<$Res> {
  _$UserMessageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of UserMessage
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = null,
    Object? connection = null,
    Object? sender = null,
    Object? receiver = null,
    Object? text = freezed,
    Object? parent = freezed,
    Object? voiceNote = freezed,
    Object? createdAt = freezed,
    Object? updatedAt = freezed,
    Object? deliverTime = freezed,
    Object? seenTime = freezed,
  }) {
    return _then(_value.copyWith(
      key: null == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as int,
      connection: null == connection
          ? _value.connection
          : connection // ignore: cast_nullable_to_non_nullable
              as int,
      sender: null == sender
          ? _value.sender
          : sender // ignore: cast_nullable_to_non_nullable
              as String,
      receiver: null == receiver
          ? _value.receiver
          : receiver // ignore: cast_nullable_to_non_nullable
              as String,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      parent: freezed == parent
          ? _value.parent
          : parent // ignore: cast_nullable_to_non_nullable
              as String?,
      voiceNote: freezed == voiceNote
          ? _value.voiceNote
          : voiceNote // ignore: cast_nullable_to_non_nullable
              as String?,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int?,
      updatedAt: freezed == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      deliverTime: freezed == deliverTime
          ? _value.deliverTime
          : deliverTime // ignore: cast_nullable_to_non_nullable
              as int?,
      seenTime: freezed == seenTime
          ? _value.seenTime
          : seenTime // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$UserMessageImplCopyWith<$Res>
    implements $UserMessageCopyWith<$Res> {
  factory _$$UserMessageImplCopyWith(
          _$UserMessageImpl value, $Res Function(_$UserMessageImpl) then) =
      __$$UserMessageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int key,
      int connection,
      String sender,
      String receiver,
      String? text,
      String? parent,
      String? voiceNote,
      int? createdAt,
      int? updatedAt,
      int? deliverTime,
      int? seenTime});
}

/// @nodoc
class __$$UserMessageImplCopyWithImpl<$Res>
    extends _$UserMessageCopyWithImpl<$Res, _$UserMessageImpl>
    implements _$$UserMessageImplCopyWith<$Res> {
  __$$UserMessageImplCopyWithImpl(
      _$UserMessageImpl _value, $Res Function(_$UserMessageImpl) _then)
      : super(_value, _then);

  /// Create a copy of UserMessage
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = null,
    Object? connection = null,
    Object? sender = null,
    Object? receiver = null,
    Object? text = freezed,
    Object? parent = freezed,
    Object? voiceNote = freezed,
    Object? createdAt = freezed,
    Object? updatedAt = freezed,
    Object? deliverTime = freezed,
    Object? seenTime = freezed,
  }) {
    return _then(_$UserMessageImpl(
      key: null == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as int,
      connection: null == connection
          ? _value.connection
          : connection // ignore: cast_nullable_to_non_nullable
              as int,
      sender: null == sender
          ? _value.sender
          : sender // ignore: cast_nullable_to_non_nullable
              as String,
      receiver: null == receiver
          ? _value.receiver
          : receiver // ignore: cast_nullable_to_non_nullable
              as String,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      parent: freezed == parent
          ? _value.parent
          : parent // ignore: cast_nullable_to_non_nullable
              as String?,
      voiceNote: freezed == voiceNote
          ? _value.voiceNote
          : voiceNote // ignore: cast_nullable_to_non_nullable
              as String?,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int?,
      updatedAt: freezed == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      deliverTime: freezed == deliverTime
          ? _value.deliverTime
          : deliverTime // ignore: cast_nullable_to_non_nullable
              as int?,
      seenTime: freezed == seenTime
          ? _value.seenTime
          : seenTime // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UserMessageImpl with DiagnosticableTreeMixin implements _UserMessage {
  const _$UserMessageImpl(
      {required this.key,
      required this.connection,
      required this.sender,
      required this.receiver,
      this.text,
      this.parent,
      this.voiceNote,
      this.createdAt,
      this.updatedAt,
      this.deliverTime,
      this.seenTime});

  factory _$UserMessageImpl.fromJson(Map<String, dynamic> json) =>
      _$$UserMessageImplFromJson(json);

  @override
  final int key;
  @override
  final int connection;
  @override
  final String sender;
  @override
  final String receiver;
  @override
  final String? text;
  @override
  final String? parent;
  @override
  final String? voiceNote;
  @override
  final int? createdAt;
  @override
  final int? updatedAt;
  @override
  final int? deliverTime;
  @override
  final int? seenTime;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'UserMessage(key: $key, connection: $connection, sender: $sender, receiver: $receiver, text: $text, parent: $parent, voiceNote: $voiceNote, createdAt: $createdAt, updatedAt: $updatedAt, deliverTime: $deliverTime, seenTime: $seenTime)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'UserMessage'))
      ..add(DiagnosticsProperty('key', key))
      ..add(DiagnosticsProperty('connection', connection))
      ..add(DiagnosticsProperty('sender', sender))
      ..add(DiagnosticsProperty('receiver', receiver))
      ..add(DiagnosticsProperty('text', text))
      ..add(DiagnosticsProperty('parent', parent))
      ..add(DiagnosticsProperty('voiceNote', voiceNote))
      ..add(DiagnosticsProperty('createdAt', createdAt))
      ..add(DiagnosticsProperty('updatedAt', updatedAt))
      ..add(DiagnosticsProperty('deliverTime', deliverTime))
      ..add(DiagnosticsProperty('seenTime', seenTime));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserMessageImpl &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.connection, connection) ||
                other.connection == connection) &&
            (identical(other.sender, sender) || other.sender == sender) &&
            (identical(other.receiver, receiver) ||
                other.receiver == receiver) &&
            (identical(other.text, text) || other.text == text) &&
            (identical(other.parent, parent) || other.parent == parent) &&
            (identical(other.voiceNote, voiceNote) ||
                other.voiceNote == voiceNote) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.updatedAt, updatedAt) ||
                other.updatedAt == updatedAt) &&
            (identical(other.deliverTime, deliverTime) ||
                other.deliverTime == deliverTime) &&
            (identical(other.seenTime, seenTime) ||
                other.seenTime == seenTime));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      key,
      connection,
      sender,
      receiver,
      text,
      parent,
      voiceNote,
      createdAt,
      updatedAt,
      deliverTime,
      seenTime);

  /// Create a copy of UserMessage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UserMessageImplCopyWith<_$UserMessageImpl> get copyWith =>
      __$$UserMessageImplCopyWithImpl<_$UserMessageImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$UserMessageImplToJson(
      this,
    );
  }
}

abstract class _UserMessage implements UserMessage {
  const factory _UserMessage(
      {required final int key,
      required final int connection,
      required final String sender,
      required final String receiver,
      final String? text,
      final String? parent,
      final String? voiceNote,
      final int? createdAt,
      final int? updatedAt,
      final int? deliverTime,
      final int? seenTime}) = _$UserMessageImpl;

  factory _UserMessage.fromJson(Map<String, dynamic> json) =
      _$UserMessageImpl.fromJson;

  @override
  int get key;
  @override
  int get connection;
  @override
  String get sender;
  @override
  String get receiver;
  @override
  String? get text;
  @override
  String? get parent;
  @override
  String? get voiceNote;
  @override
  int? get createdAt;
  @override
  int? get updatedAt;
  @override
  int? get deliverTime;
  @override
  int? get seenTime;

  /// Create a copy of UserMessage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UserMessageImplCopyWith<_$UserMessageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

MessageAttachments _$MessageAttachmentsFromJson(Map<String, dynamic> json) {
  return _MessageAttachments.fromJson(json);
}

/// @nodoc
mixin _$MessageAttachments {
  List<String> get picture => throw _privateConstructorUsedError;
  List<String> get video => throw _privateConstructorUsedError;

  /// Serializes this MessageAttachments to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of MessageAttachments
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $MessageAttachmentsCopyWith<MessageAttachments> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MessageAttachmentsCopyWith<$Res> {
  factory $MessageAttachmentsCopyWith(
          MessageAttachments value, $Res Function(MessageAttachments) then) =
      _$MessageAttachmentsCopyWithImpl<$Res, MessageAttachments>;
  @useResult
  $Res call({List<String> picture, List<String> video});
}

/// @nodoc
class _$MessageAttachmentsCopyWithImpl<$Res, $Val extends MessageAttachments>
    implements $MessageAttachmentsCopyWith<$Res> {
  _$MessageAttachmentsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of MessageAttachments
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? picture = null,
    Object? video = null,
  }) {
    return _then(_value.copyWith(
      picture: null == picture
          ? _value.picture
          : picture // ignore: cast_nullable_to_non_nullable
              as List<String>,
      video: null == video
          ? _value.video
          : video // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MessageAttachmentsImplCopyWith<$Res>
    implements $MessageAttachmentsCopyWith<$Res> {
  factory _$$MessageAttachmentsImplCopyWith(_$MessageAttachmentsImpl value,
          $Res Function(_$MessageAttachmentsImpl) then) =
      __$$MessageAttachmentsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<String> picture, List<String> video});
}

/// @nodoc
class __$$MessageAttachmentsImplCopyWithImpl<$Res>
    extends _$MessageAttachmentsCopyWithImpl<$Res, _$MessageAttachmentsImpl>
    implements _$$MessageAttachmentsImplCopyWith<$Res> {
  __$$MessageAttachmentsImplCopyWithImpl(_$MessageAttachmentsImpl _value,
      $Res Function(_$MessageAttachmentsImpl) _then)
      : super(_value, _then);

  /// Create a copy of MessageAttachments
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? picture = null,
    Object? video = null,
  }) {
    return _then(_$MessageAttachmentsImpl(
      picture: null == picture
          ? _value._picture
          : picture // ignore: cast_nullable_to_non_nullable
              as List<String>,
      video: null == video
          ? _value._video
          : video // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageAttachmentsImpl
    with DiagnosticableTreeMixin
    implements _MessageAttachments {
  const _$MessageAttachmentsImpl(
      {required final List<String> picture, required final List<String> video})
      : _picture = picture,
        _video = video;

  factory _$MessageAttachmentsImpl.fromJson(Map<String, dynamic> json) =>
      _$$MessageAttachmentsImplFromJson(json);

  final List<String> _picture;
  @override
  List<String> get picture {
    if (_picture is EqualUnmodifiableListView) return _picture;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_picture);
  }

  final List<String> _video;
  @override
  List<String> get video {
    if (_video is EqualUnmodifiableListView) return _video;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_video);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'MessageAttachments(picture: $picture, video: $video)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'MessageAttachments'))
      ..add(DiagnosticsProperty('picture', picture))
      ..add(DiagnosticsProperty('video', video));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageAttachmentsImpl &&
            const DeepCollectionEquality().equals(other._picture, _picture) &&
            const DeepCollectionEquality().equals(other._video, _video));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_picture),
      const DeepCollectionEquality().hash(_video));

  /// Create a copy of MessageAttachments
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageAttachmentsImplCopyWith<_$MessageAttachmentsImpl> get copyWith =>
      __$$MessageAttachmentsImplCopyWithImpl<_$MessageAttachmentsImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageAttachmentsImplToJson(
      this,
    );
  }
}

abstract class _MessageAttachments implements MessageAttachments {
  const factory _MessageAttachments(
      {required final List<String> picture,
      required final List<String> video}) = _$MessageAttachmentsImpl;

  factory _MessageAttachments.fromJson(Map<String, dynamic> json) =
      _$MessageAttachmentsImpl.fromJson;

  @override
  List<String> get picture;
  @override
  List<String> get video;

  /// Create a copy of MessageAttachments
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$MessageAttachmentsImplCopyWith<_$MessageAttachmentsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
